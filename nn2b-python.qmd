
---
title: "Recurrent Neural Network (LSTM) â€” Sine Wave (CPU-Only)"
format:
  html:
    code-fold: false
  pdf:
    toc: true
jupyter: python3
---

# LSTM on a Sine Wave (CPU-Only TensorFlow)

This chapter reproduces the R RNN chapter using Python, using a sine wave and manual RMSE.  
TensorFlow is explicitly forced to run on CPU to avoid Metal/GPU-related kernel crashes during Quarto rendering.

---

## 0. TensorFlow CPU-Only Setup and Diagnostics

```{python}
import os

# Force CPU-only execution and quiet logs a bit
os.environ["CUDA_VISIBLE_DEVICES"] = "-1"
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"
os.environ["TF_ENABLE_ONEDNN_OPTS"] = "0"

import tensorflow as tf

print("TensorFlow version:", tf.__version__)
print("Physical devices:", tf.config.list_physical_devices())

# Safely attempt to hide GPUs if any are visible
try:
    tf.config.set_visible_devices([], "GPU")
    print("Set visible devices to CPU-only.")
except Exception as e:
    print("Could not set visible GPU devices (this is usually fine):", e)
```

---

## 1. Generate Sine Wave

```{python
import numpy as np
import matplotlib.pyplot as plt

n_points = 2000
t = np.linspace(0, 40*np.pi, n_points)
signal = np.sin(t)

plt.plot(t, signal)
plt.title("Sine Wave")
plt.show()
```

---

## 2. Build Sequences

```{python}
def create_sequences(series, seq_length=50):
    X_list, y_list = [], []
    for i in range(len(series) - seq_length):
        X_list.append(series[i:i+seq_length])
        y_list.append(series[i+seq_length])
    X = np.array(X_list)[..., np.newaxis]
    y = np.array(y_list)
    return X, y

seq_length = 50
X_seq, y_seq = create_sequences(signal, seq_length)
```

---

## 3. Train/Test Split

```{python}
split = int(0.8 * X_seq.shape[0])

X_train_seq = X_seq[:split]
y_train_seq = y_seq[:split]
X_test_seq = X_seq[split:]
y_test_seq = y_seq[split:]
```

---

## 4. LSTM Model

```{python}
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.metrics import mean_squared_error

tf.random.set_seed(12345)

model = keras.Sequential([
    keras.Input(shape=(seq_length,1)),
    layers.LSTM(32),
    layers.Dense(1)
])

model.compile(optimizer="adam", loss="mse")
model.summary()
```

```{python}
history = model.fit(
    X_train_seq, y_train_seq,
    epochs=20, batch_size=32,
    validation_split=0.2, verbose=0
)

plt.plot(history.history["loss"], label="Train")
plt.plot(history.history["val_loss"], label="Val")
plt.legend()
plt.title("LSTM Loss")
plt.show()
```

---

## 5. Evaluate

```{python}
pred_seq = model.predict(X_test_seq).flatten()

rmse_lstm = mean_squared_error(y_test_seq, pred_seq) ** 0.5
rmse_lstm
```
